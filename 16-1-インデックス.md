MySQLではテーブルに格納されるデータは、通常レコード単位で蓄積される。レコードが増えてくると、`WHERE`などでレコードを抽出する際にテーブルの全レコードを走査すると抽出に非常に時間がかかる。これを効率化するためにインデックスが用いられる。インデックスはテーブルの特定のカラム、あるいはカラムの組み合わせに対して追加で作成されるデータ構造である。書籍の索引に例えられることが多い。ページ番号と内容が紐づけられているのと同じイメージで、どの列のどの値がテーブル上のどの行に対応しているかを素早く探せるように構築される。インデックスを作ることで高速に検索できることを確認するためのテーブルとデータの作成を`16-0-generate.sh`で行う。
```
# 雑に実行権限を与えて実行。
chmod 777 16-0-generate.sh
./16-0-generate.sh
```
実行が完了すると以下のようなテーブルが作成され、1000万件のレコードが挿入されている。
```
mysql> show create table test_index;
CREATE TABLE `test_index` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
)

mysql> select count(*) from test_index;
+----------+
| count(*) |
+----------+
| 10000000 |
+----------+

-- 以下のようなデータが1000万件分入っている。
mysql> select * from test_index limit 10;
+----+--------+
| id | name   |
+----+--------+
|  1 | name1  |
|  2 | name2  |
|  3 | name3  |
|  4 | name4  |
|  5 | name5  |
|  6 | name6  |
|  7 | name7  |
|  8 | name8  |
|  9 | name9  |
| 10 | name10 |
+----+--------+
10 rows in set (0.00 sec)


```
nameカラムでレコードを絞り込むと3秒程度かかっていることが確認できる。
```
mysql> select * from test_index where name = "name5000000";
+---------+-------------+
| id      | name        |
+---------+-------------+
| 5000000 | name5000000 |
+---------+-------------+
1 row in set (2.98 sec)
```
以下のクエリでnameカラムにインデックスを作成する。
```
mysql> create index idx_name on test_index (name);
Query OK, 0 rows affected (51.23 sec)
Records: 0  Duplicates: 0  Warnings: 0
```
再度同じ条件で検索すると今度は瞬時に終わっていることがわかる。
```
mysql> select * from test_index where name = "name5000000";
+---------+-------------+
| id      | name        |
+---------+-------------+
| 5000000 | name5000000 |
+---------+-------------+
1 row in set (0.00 sec)
```
インデックスを作るメリットは検索の高速化だけでなく、ソート性能の向上や`JOIN`の高速化などがある。ただし、`INSERT`, `UPDATE`, `DELETE`のたびにインデックスも更新されるため、書き込み性能が低下する。そのため、どの列に作るかは慎重に選ぶ必要がある。複数のカラムを組み合わせてインデックスを作ることもできるが、列の順序によって有効度が変わってくるため、どのような検索パターンが多いのかを把握し、それに合わせてインデックスを作る必要がある。以下のクエリでは、あるユーザーの注文履歴を日付順にみたいというクエリが頻繁にあることを想定し、利用者と注文日でインデックスを作成している。
```
-- テーブル定義時点でインデックスを作成することも可能
mysql> create table orders (
    ->     id int primary key auto_increment,
    ->     user_id int not null,
    ->     order_date datetime not null,
    ->     index idx_user_date (user_id, order_date)
    -> );
Query OK, 0 rows affected (0.07 sec)
```
基本的には、数値型・文字列型・日付型・時刻型は制限なくインデックス作成が可能である。一方、`TEXT`, `BLOB`, `JSON`などインデックス作成に制限・注意が必要なデータ型も存在する。例えば、`TEXT`は以下のクエリのように先頭何バイトかだけを対象にインデックスを作成したりする必要がある。インデックスを作成したい場合はデータ型に応じてどのように作成するか都度調べる必要がある。
```
mysql> create table articles (
    ->     id int auto_increment primary key,
    ->     content text,
    ->     -- 先頭255バイトに対してインデックスを設定
    ->     index idx_content_prefix (content(255))
    -> );
Query OK, 0 rows affected (0.07 sec)
```
インデックスが作成可能な場合でも、検索方法によっては注意が必要な場合がある。例えば、`LIKE`では先頭部分を一致させる処理(`"xx%"`など)にはインデックスを利用できるが、前方が不定の検索(`"%xx"`など)では原則としてインデックスは活用できない（フルテキストインデックスを活用できるなど例外を除く）。